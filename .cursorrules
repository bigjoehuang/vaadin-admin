# Vaadin Admin 项目开发规范

## 项目信息
- 项目名称: vaadin-admin
- 包名: com.admin
- 技术栈: Vaadin 24.x + Spring Boot 3.2.x + MyBatis 3.0.x + JDK 21 + MySQL + Redis + Flyway

## 数据库规范

### 表结构规范
1. **固定字段顺序**：所有表的前三个字段必须为：
   - `id` INT UNSIGNED PRIMARY KEY AUTO_INCREMENT
   - `createdAt` DATETIME NOT NULL COMMENT '创建时间'
   - `updatedAt` DATETIME NOT NULL COMMENT '更新时间'

2. **字段命名**：
   - 使用驼峰命名（camelCase），如 `userName`、`createTime`、`isDeleted`
   - 布尔类型字段使用 `is` 前缀，如 `isDeleted`、`isEnabled`
   - 时间字段统一使用 `At` 后缀，如 `createdAt`、`updatedAt`、`deletedAt`

3. **表命名**：
   - 使用下划线命名，如 `sys_user`、`sys_role`、`sys_permission`
   - 系统表使用 `sys_` 前缀
   - 业务表使用模块前缀，如 `biz_order`、`biz_product`

4. **主键规范**：
   - 统一使用 `id` 作为主键
   - 类型为 `INT UNSIGNED`
   - 自增：`AUTO_INCREMENT`
   - Java 类型映射：`INT UNSIGNED` 对应 Java 的 `Long` 类型（范围：0 到 4294967295）

5. **逻辑删除**：
   - 使用 `deleted` 字段，类型为 `TINYINT`
   - 0 表示未删除，1 表示已删除
   - 默认值为 0

6. **时间字段**：
   - 创建时间：`createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP`
   - 更新时间：`updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`

### 示例表结构
```sql
CREATE TABLE sys_user (
    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    userName VARCHAR(50) NOT NULL COMMENT '用户名',
    password VARCHAR(255) NOT NULL COMMENT '密码',
    email VARCHAR(100) COMMENT '邮箱',
    phone VARCHAR(20) COMMENT '手机号',
    isEnabled TINYINT DEFAULT 1 COMMENT '是否启用',
    deleted TINYINT DEFAULT 0 COMMENT '是否删除'
) COMMENT='用户表';
```

## 代码风格规范

### 遵循标准
- 遵循《阿里巴巴 Java 开发手册》
- 使用 Google Java Format 格式化代码

### 命名规范

1. **类命名**（大驼峰 PascalCase）：
   - 实体类：`User`、`Role`、`Permission`
   - 服务类：`UserService`、`UserServiceImpl`
   - 控制器：`UserController`
   - 工具类：`StringUtil`、`DateUtil`
   - 异常类：`BusinessException`、`ValidationException`

2. **方法/变量命名**（小驼峰 camelCase）：
   - 方法：`getUserById`、`saveUser`、`deleteUser`
   - 变量：`userName`、`userList`、`isEnabled`
   - 参数：`userId`、`userName`

3. **常量命名**（全大写下划线）：
   - `MAX_SIZE`、`DEFAULT_PAGE_SIZE`、`DEFAULT_PASSWORD`

4. **包命名**（全小写，点分隔）：
   - `com.admin.entity`
   - `com.admin.service`
   - `com.admin.controller`

## 包结构规范

### 标准分层结构
```
com.admin
├── entity/          # 实体类
├── mapper/          # MyBatis Mapper 接口
├── service/         # 服务层接口
│   └── impl/        # 服务层实现
├── controller/      # 控制器（API）
├── views/           # Vaadin 视图
├── component/       # 自定义组件
├── util/            # 工具类
├── config/          # 配置类
├── exception/       # 异常类
├── aspect/          # AOP 切面
├── annotation/      # 自定义注解
├── dto/             # 数据传输对象
└── generator/       # 代码生成器
```

## 实体类规范

### BaseEntity 基类
所有实体类必须继承 `BaseEntity`：
```java
@Data
public abstract class BaseEntity {
    private Long id;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

### 实体类示例
```java
@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_user")
public class User extends BaseEntity {
    private String userName;
    private String password;
    private String email;
    private String phone;
    private Boolean isEnabled;
    private Integer deleted;
}
```

### 实体类注解
- 使用 Lombok：`@Data`、`@Builder`、`@NoArgsConstructor`、`@AllArgsConstructor`
- MyBatis-Plus：`@TableName`、`@TableId`、`@TableField`
- 验证注解：`@NotNull`、`@NotBlank`、`@Size`、`@Email`

## 服务层规范

### 接口命名
- 接口：`XxxService`，如 `UserService`
- 实现类：`XxxServiceImpl`，如 `UserServiceImpl`

### 方法命名规范
- **查询**：
  - 单个：`getXxxById`、`getXxx`
  - 列表：`listXxx`、`listXxxByCondition`
  - 分页：`pageXxx`、`pageXxxByCondition`
- **新增**：`saveXxx`、`createXxx`
- **更新**：`updateXxx`、`updateXxxById`
- **删除**：`deleteXxx`、`deleteXxxById`、`removeXxx`

### 服务层示例
```java
public interface UserService {
    User getUserById(Long id);
    List<User> listUsers();
    PageResult<User> pageUsers(PageRequest request);
    void saveUser(User user);
    void updateUser(User user);
    void deleteUser(Long id);
}
```

## 控制器规范

### 类注解
```java
@RestController
@RequestMapping("/api/user")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;
}
```

### 方法注解和命名
- `@GetMapping("/list")` - 列表查询
- `@GetMapping("/{id}")` - 详情查询
- `@PostMapping` - 新增
- `@PutMapping("/{id}")` - 更新
- `@DeleteMapping("/{id}")` - 删除

### 统一返回格式
```java
@GetMapping("/{id}")
public Result<User> getUser(@PathVariable Long id) {
    User user = userService.getUserById(id);
    return Result.success(user);
}
```

## API 设计规范

### RESTful 风格
- **GET** `/api/user/list` - 列表查询
- **GET** `/api/user/{id}` - 详情查询
- **POST** `/api/user` - 新增
- **PUT** `/api/user/{id}` - 更新
- **DELETE** `/api/user/{id}` - 删除

### 统一响应格式
```java
public class Result<T> {
    private Integer code;      // 200-成功，其他-失败
    private String message;    // 提示信息
    private T data;            // 返回数据
}

// 分页响应
public class PageResult<T> {
    private Integer code;
    private String message;
    private PageData<T> data;
}

public class PageData<T> {
    private List<T> list;      // 数据列表
    private Long total;        // 总记录数
    private Integer pageNum;   // 当前页码
    private Integer pageSize;  // 每页大小
}
```

### 错误码定义
- `200` - 成功
- `400` - 参数错误
- `401` - 未授权
- `403` - 无权限
- `404` - 资源不存在
- `500` - 服务器错误

## 异常处理规范

### 业务异常
```java
public class BusinessException extends RuntimeException {
    private Integer code;
    private String message;
}

// 使用示例
throw new BusinessException(ErrorCode.USER_NOT_FOUND, "用户不存在");
```

### 全局异常处理
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        return Result.error(e.getCode(), e.getMessage());
    }
}
```

## 日志规范

### 使用 SLF4J
```java
private static final Logger log = LoggerFactory.getLogger(UserService.class);

log.info("查询用户，ID: {}", userId);
log.error("删除用户失败，ID: {}", userId, e);
```

### 日志级别
- **ERROR**：系统错误、异常
- **WARN**：警告信息
- **INFO**：重要操作、业务流程
- **DEBUG**：调试信息（生产环境关闭）

## 注释规范

### 类注释
```java
/**
 * 用户服务接口
 * 
 * @author Admin
 * @date 2024-01-01
 */
public interface UserService {
}
```

### 方法注释
```java
/**
 * 根据ID查询用户
 * 
 * @param id 用户ID
 * @return 用户信息
 * @throws BusinessException 用户不存在时抛出
 */
User getUserById(Long id);
```

## 测试规范

### 测试类命名
- 测试类：`XxxServiceTest`，如 `UserServiceTest`
- 测试方法：`testXxx`，如 `testGetUserById`

### 测试示例
```java
@SpringBootTest
class UserServiceTest {
    @Autowired
    private UserService userService;
    
    @Test
    void testGetUserById() {
        User user = userService.getUserById(1L);
        assertNotNull(user);
    }
}
```

## MyBatis 规范

### Mapper 接口
```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    List<User> selectByCondition(@Param("condition") UserCondition condition);
}
```

### XML 映射文件
- 位置：`resources/mapper/`
- 命名：`XxxMapper.xml`
- 使用 `<if>`、`<where>`、`<foreach>` 等标签

## Vaadin 视图规范

### 视图类命名
- 列表视图：`XxxListView`，如 `UserListView`
- 表单视图：`XxxFormView`，如 `UserFormView`
- 详情视图：`XxxDetailView`，如 `UserDetailView`

### 路由注解
```java
@Route("users")
@PageTitle("用户管理")
public class UserListView extends VerticalLayout {
}
```

### 组件使用
- 使用 Vaadin 标准组件
- 自定义组件放在 `component` 包
- 样式使用主题 CSS，避免内联样式

## 代码生成器规范

### 生成文件
- Entity：实体类
- Mapper：Mapper 接口和 XML
- Service：服务接口和实现
- Controller：控制器
- View：Vaadin 视图

### 模板位置
- `resources/generator/template/`
- 使用 FreeMarker 模板引擎

## 其他规范

### 日期时间
- 使用 `LocalDateTime`（Java 8+）
- 数据库字段类型：`DATETIME`

### 布尔类型
- Java：`Boolean` 或 `boolean`
- 数据库：`TINYINT`，0-false，1-true

### 集合类型
- 使用 `List`、`Set`、`Map`
- 避免使用 `Vector`、`Hashtable` 等过时类

### 字符串处理
- 使用 `StringUtils`（Hutool 或 Apache Commons）
- 避免 `==` 比较字符串，使用 `equals()`

### 空值处理
- 使用 `Optional` 处理可能为空的值
- 使用 `@Nullable`、`@NonNull` 注解标注

## Flyway 数据库版本管理规范

### 迁移脚本位置
- 所有迁移脚本放在：`src/main/resources/db/migration/`
- 不要手动创建表，所有表结构变更都通过 Flyway 迁移脚本

### 命名规范

1. **版本迁移脚本**（Versioned Migrations）：
   - 格式：`V{version}__{description}.sql`
   - 示例：`V1__Initial_schema.sql`、`V2__Create_user_table.sql`
   - 版本号规则：
     - 使用递增整数：V1、V2、V3...
     - 版本号必须唯一且严格递增
     - 不能跳过版本号（如 V1 后不能直接 V3）
   - 描述规则：
     - 使用下划线分隔单词
     - 描述要清晰说明脚本用途
     - 示例：`Create_user_table`、`Add_email_to_user_table`

2. **可重复迁移脚本**（Repeatable Migrations）：
   - 格式：`R__{description}.sql`
   - 示例：`R__Insert_default_data.sql`、`R__Update_menu_permissions.sql`
   - 用途：用于数据初始化、视图、存储过程等可重复执行的脚本
   - 执行规则：每次启动时检查校验和，如果变化则重新执行

### 脚本内容规范

1. **幂等性要求**：
   - 所有脚本必须是可重复执行的（幂等性）
   - 使用 `IF NOT EXISTS` 或 `DROP TABLE IF EXISTS` 保证幂等性
   - 示例：
   ```sql
   -- 正确：幂等性
   CREATE TABLE IF NOT EXISTS sys_user (
       id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
       createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
       updatedAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
       userName VARCHAR(50) NOT NULL
   );
   
   -- 错误：非幂等性
   CREATE TABLE sys_user (...);  -- 如果表已存在会报错
   ```

2. **注释规范**：
   - 每个脚本开头必须添加注释说明用途
   - 复杂操作添加行内注释
   - 示例：
   ```sql
   -- 创建用户表
   -- 包含基础字段：id, createdAt, updatedAt, userName, password
   CREATE TABLE IF NOT EXISTS sys_user (
       ...
   );
   ```

3. **事务处理**：
   - 每个脚本自动在一个事务中执行
   - 如果脚本执行失败，整个脚本会回滚
   - 不要在脚本中使用 `COMMIT` 或 `ROLLBACK`

4. **DDL 和 DML 分离**：
   - 表结构变更（DDL）使用版本迁移脚本（V开头）
   - 数据初始化（DML）使用可重复迁移脚本（R开头）或版本迁移脚本

### 执行顺序

1. **版本迁移脚本**：
   - 按版本号顺序执行
   - 已执行的脚本不会重复执行
   - 如果中间某个版本失败，后续版本不会执行

2. **可重复迁移脚本**：
   - 在所有版本迁移脚本执行完成后执行
   - 按文件名排序执行
   - 每次启动时检查校验和，如果变化则重新执行

### 配置文件

在 `application.yml` 中配置 Flyway：

```yaml
spring:
  flyway:
    enabled: true                    # 启用 Flyway
    locations: classpath:db/migration # 迁移脚本位置
    baseline-on-migrate: true        # 在已有数据库上启用基线
    baseline-version: 0               # 基线版本号
    validate-on-migrate: true        # 迁移时验证
    clean-disabled: true              # 禁用 clean 命令（生产环境）
    out-of-order: false              # 不允许乱序执行
    table: flyway_schema_history      # 版本历史表名
```

### 开发流程

1. **创建新表**：
   - 创建版本迁移脚本，如 `V3__Create_role_table.sql`
   - 遵循命名规范和幂等性要求
   - 提交到版本控制

2. **修改表结构**：
   - 创建新的版本迁移脚本，如 `V4__Add_status_to_user_table.sql`
   - 使用 `ALTER TABLE` 语句
   - 确保脚本可以重复执行（使用 `IF NOT EXISTS` 等）

3. **初始化数据**：
   - 使用可重复迁移脚本，如 `R__Insert_default_roles.sql`
   - 或使用版本迁移脚本（如果是一次性数据）

4. **回滚处理**：
   - Flyway 不支持自动回滚
   - 如需回滚，创建新的迁移脚本撤销变更
   - 或手动执行回滚 SQL

### 注意事项

1. **不要修改已执行的脚本**：
   - 已执行的脚本不能修改
   - 如需修改，创建新的迁移脚本

2. **版本号管理**：
   - 版本号必须递增
   - 团队协作时注意版本号冲突
   - 建议使用时间戳作为版本号的一部分，如 `V20240101001__`

3. **测试环境验证**：
   - 所有迁移脚本先在测试环境验证
   - 确保脚本可以重复执行（幂等性）

4. **生产环境部署**：
   - 生产环境部署前备份数据库
   - 确保迁移脚本已充分测试
   - 监控迁移执行结果

5. **Flyway 历史表**：
   - Flyway 会自动创建 `flyway_schema_history` 表
   - 不要手动修改此表
   - 此表记录所有已执行的迁移脚本

## 注意事项

1. **所有代码必须遵循以上规范**
2. **数据库表必须包含 id、createdAt、updatedAt 三个字段**
3. **所有实体类必须继承 BaseEntity**
4. **API 必须返回统一的 Result 格式**
5. **异常必须使用 BusinessException 或全局异常处理**
6. **日志必须使用 SLF4J，避免使用 System.out.println**
7. **代码必须添加必要的注释和 JavaDoc**
8. **数据库变更必须通过 Flyway 迁移脚本，不要手动创建或修改表结构**
9. **Flyway 迁移脚本必须遵循命名规范和幂等性要求**

